\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumitem}

\usepackage{listings}
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\title{Semester project -- Pong Designer\\Technical report}
\author{Lomig MÃ©gard}

\begin{document}
\maketitle

\section{Type system}
The type system relies on type classes in Scala. For example, the signature of a property restrains the generic type that can be used.
\begin{lstlisting}
abstract class Property[T : PongType](...) {}
\end{lstlisting}

The \texttt{PongType} is defined in such a way we can translate an internal result of the interpreter to a Scala object, and the other way around.
\begin{lstlisting}
trait PongType[T] {
  def getPongType: Type
  def toPongValue(v: Any): Value
  def toScalaValue(v: Value): T
  def clone(v: T): T
}
\end{lstlisting}

The following method illustrates how these types can be used. The \texttt{Context} contains some global information required for the evaluation, as for example the current finger movements.
\begin{lstlisting}
def typecheckAndEvaluate[T : PongType](e: Expr): T = {
  typeCheck(e, implicitly[PongType[T]].getPongType)
  eval(e)(Context).as[T]
}
\end{lstlisting}

\clearpage
\section{Expressions and statements}
The AST of statements is illustrated in figure \ref{fig:AST-stats}. All classes are immutable but can reference a property whom value can change. Statements can have side-effect, here modifying a property value with the \texttt{Assign} operation. 

\begin{figure*}[h]
\centering
\includegraphics[scale = 0.7]{images/AST_stats} 
\caption{AST of statements.}
\label{fig:AST-stats}
\end{figure*}

The expressions cannot have side-effects. Here is a summarized list of the different kinds of expressions. The different expressions that use finger position and objects collision need a context to be evaluated. It is provided by the game engine that exposes the asynchronous events of the last terminated time step.
\begin{itemize}[noitemsep,topsep=2pt,parsep=1pt,partopsep=1pt]
\item Literals: \texttt{IntegerLiteral}, \texttt{StringLiteral}, ...
\item Arithmetic: \texttt{Add}, \texttt{Minus}, \texttt{Mod}, ...
\item Boolean: \texttt{And}, \texttt{LessThan}, \texttt{Equals}, ...
\item Finger: \texttt{MoveOver}, \texttt{DownOn}, ...
\item Collision
\item Property
\end{itemize}

\section{Game objects}
This project uses JBox2D version 2.2.1.1 for its physical engine. Since Pong Designer needs to handle the history of all properties, a wrapper named \texttt{PhysicalObject} is built around each JBox2D body. It takes care of instantiating the body with arbitrary expressions in the world and of managing the different properties with their history. 

\begin{figure*}[h]
\centering
\includegraphics[scale = 0.7]{images/objects} 
\caption{Hierarchy of game objects.}
\label{fig:objects}
\end{figure*}

The figure \ref{fig:objects} describes how different kinds of game objects inherit from the same trait \texttt{GameObject}. It manages all the properties that belong to its implementation in two ways. First, each property is a class member of \texttt{GameObject} or of another sub-class if it is specific (an example is the circle radius). These members can be accessed only from the game engine itself, not from the user. This permits to have internally the right static Scala type for each property. Secondly, a map stores all the properties, even the ones declared in sub-classes, with their name for key. This enables the user to have access to a property from a name, but the precise type will remain unknown (it is anyway not required by the user). The following example shows how we can build a statement to increment a value.

\begin{lstlisting}
circle("x") := circle("x") + 1
\end{lstlisting}

This syntax is not very convenient but we assumed that this code would be generated by the game engine. It remains readable and meaningful.


\section{Categories}

\begin{lstlisting}
foreach(cat) { o =>
  whenever(base("y") < o("y")) { Seq(
    o("y") := 0
  )}
}

foreach(cat1, cat2) { (o1, o2) =>
  once(Collision(o1, o2)) { Seq(
    score("value") += 1
  )}  
}
\end{lstlisting}

\section{Game loop}

- Fixed time step

\subsection{Update}

During the execution of the \texttt{update()} loop:
\begin{enumerate}
\item execute the rules. The context is available and contains all asynchronous events recorded since the last iteration.
\item new values (from the rules) are flushed to the physics engine.
\item perform the physics engine \texttt{step} which computes new collisions and moves the objects.
\item load new values (from the physics engine) to the upper layer of objects.
\item save the current state to the history.
\end{enumerate}

\subsection{Render}







\end{document}
